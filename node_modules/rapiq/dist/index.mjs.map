{"version":3,"file":"index.mjs","sources":["../src/constants.ts","../src/utils/array.ts","../src/utils/object.ts","../src/utils/mapping.ts","../src/utils/field.ts","../src/utils/merge.ts","../src/utils/relation.ts","../src/utils/url.ts","../src/parameter/fields/build.ts","../src/parameter/fields/constants.ts","../src/parameter/utils/parse/allowed-option.ts","../src/parameter/fields/utils/domain.ts","../src/parameter/fields/utils/input.ts","../src/parameter/fields/utils/name.ts","../src/parameter/fields/parse.ts","../src/parameter/filters/constants.ts","../src/parameter/filters/build.ts","../src/parameter/filters/utils/value.ts","../src/parameter/filters/utils/operator.ts","../src/parameter/filters/parse.ts","../src/parameter/pagination/build.ts","../src/parameter/pagination/parse.ts","../src/parameter/relations/build.ts","../src/parameter/relations/utils/parents.ts","../src/parameter/relations/utils/path.ts","../src/parameter/relations/parse.ts","../src/parameter/sort/type.ts","../src/parameter/sort/build.ts","../src/parameter/sort/utils.ts","../src/parameter/sort/parse.ts","../src/build/module.ts","../src/parse/parameter/module.ts","../src/parse/parameter/utils.ts","../src/parse/module.ts"],"sourcesContent":["/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\n// -----------------------------------------------------------\n\nexport enum Parameter {\n    FILTERS = 'filters',\n    FIELDS = 'fields',\n    PAGINATION = 'pagination',\n    RELATIONS = 'relations',\n    SORT = 'sort',\n}\n\n// -----------------------------------------------------------\n\nexport enum URLParameter {\n    FILTERS = 'filter',\n    FIELDS = 'fields',\n    PAGINATION = 'page',\n    RELATIONS = 'include',\n    SORT = 'sort',\n}\n\n// -----------------------------------------------------------\n\nexport const DEFAULT_ID = '__DEFAULT__';\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { DEFAULT_ID } from '../constants';\n\nexport function buildKeyPath(key: string, prefix?: string) {\n    if (typeof prefix === 'string') {\n        return `${prefix}.${key}`;\n    }\n\n    return key;\n}\n\ntype Options = {\n    transformer?: (\n        input: unknown,\n        output: string[],\n        prefix?: string\n    ) => boolean | undefined\n};\n\nexport function flattenToKeyPathArray(\n    input: unknown,\n    options?: Options,\n    prefix?: string,\n): string[] {\n    options = options || {};\n\n    const output: string[] = [];\n\n    if (options.transformer) {\n        const result = options.transformer(input, output, prefix);\n        if (typeof result !== 'undefined' && !!result) {\n            return output;\n        }\n    }\n\n    if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (options.transformer) {\n                const result = options.transformer(input[i], output, prefix);\n                if (typeof result !== 'undefined' && !!result) {\n                    return output;\n                }\n            }\n\n            if (Array.isArray(input[i])) {\n                for (let j = 0; j < input[i].length; j++) {\n                    const key = buildKeyPath(input[i][j], prefix);\n                    output.push(key);\n                }\n\n                continue;\n            }\n\n            if (typeof input[i] === 'string') {\n                output.push(buildKeyPath(input[i], prefix));\n\n                continue;\n            }\n\n            if (typeof input[i] === 'object') {\n                const keys = Object.keys(input[i]);\n                for (let j = 0; j < keys.length; j++) {\n                    const value = buildKeyPath(keys[j] as string, prefix);\n                    const data = flattenToKeyPathArray(input[i][keys[j]], options, value);\n                    if (data.length === 0) {\n                        output.push(value);\n                    } else {\n                        output.push(...data);\n                    }\n                }\n            }\n        }\n\n        return output;\n    }\n\n    if (\n        typeof input === 'object' &&\n        input !== null\n    ) {\n        const keys = Object.keys(input);\n        for (let i = 0; i < keys.length; i++) {\n            const value = buildKeyPath(keys[i], prefix);\n            const data = flattenToKeyPathArray((input as Record<string, any>)[keys[i]], options, value);\n            if (data.length === 0) {\n                output.push(value);\n            } else {\n                output.push(...data);\n            }\n        }\n\n        return output;\n    }\n\n    if (\n        typeof input === 'string'\n    ) {\n        const value = buildKeyPath(input, prefix);\n        output.push(value);\n\n        return output;\n    }\n\n    return output;\n}\n\nexport function groupArrayByKeyPath(input: string[]): Record<string, string[]> {\n    const pathItems: Record<string, string[]> = {};\n\n    for (let i = 0; i < input.length; i++) {\n        const parts = input[i].split('.');\n\n        let key: string;\n        let name: string;\n        if (parts.length === 1) {\n            key = DEFAULT_ID;\n            name = input[i];\n        } else {\n            name = parts.pop() as string;\n            key = parts.join('.');\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(pathItems, key)) {\n            pathItems[key] = [];\n        }\n\n        pathItems[key].push(name);\n    }\n\n    return pathItems;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function hasOwnProperty<\n    X extends Record<string, any>,\n    Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\ntype Options = {\n    transformer?: (\n        input: unknown,\n        output: Record<string, any>,\n        key: string\n    ) => boolean | undefined\n};\n\nexport function flattenNestedObject(\n    data: Record<string, any>,\n    options?: Options,\n    prefixParts?: string[],\n): Record<string, any> {\n    options = options || {};\n    prefixParts = prefixParts || [];\n\n    let output: Record<string, string> = {};\n\n    if (options.transformer) {\n        const result = options.transformer(data, output, prefixParts.join('.'));\n        if (typeof result !== 'undefined' && !!result) {\n            return output;\n        }\n    }\n\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (options.transformer) {\n            const result = options.transformer(data[key], output, [...prefixParts, key].join('.'));\n            if (typeof result !== 'undefined' && !!result) {\n                continue;\n            }\n        }\n\n        if (\n            typeof data[key] === 'object' &&\n            data[key]\n        ) {\n            output = { ...output, ...flattenNestedObject(data[key], options, [...prefixParts, key]) };\n\n            continue;\n        }\n\n        const destinationKey = [...prefixParts, key].join('.');\n\n        if (\n            typeof data[key] === 'boolean' ||\n            typeof data[key] === 'string' ||\n            typeof data[key] === 'number' ||\n            typeof data[key] === 'undefined' ||\n            data[key] === null ||\n            Array.isArray(data[key])\n        ) {\n            output[destinationKey] = data[key];\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { hasOwnProperty } from './object';\n\nexport function applyMapping(\n    name: string,\n    map?: Record<string, string>,\n    onlyKey?: boolean,\n) {\n    if (typeof map === 'undefined') {\n        return name;\n    }\n\n    let parts = name.split('.');\n\n    const output = [];\n    let run = true;\n    while (run) {\n        const value = parts.shift();\n        if (typeof value === 'undefined') {\n            run = false;\n            break;\n        }\n\n        if (hasOwnProperty(map, value)) {\n            output.push(map[value]);\n        } else {\n            let found = false;\n\n            const rest : string[] = [];\n            const copy = [...parts];\n            while (copy.length > 0) {\n                const key = [value, ...copy].join('.');\n                if (hasOwnProperty(map, key)) {\n                    output.push(map[key]);\n                    found = true;\n                    break;\n                } else {\n                    const last = copy.pop();\n                    if (last) {\n                        rest.unshift(last);\n                    }\n                }\n            }\n\n            if (found) {\n                parts = rest;\n            } else {\n                output.push(value);\n            }\n        }\n    }\n\n    if (onlyKey) {\n        return output.pop() || name;\n    }\n\n    if (output.length === 0) {\n        return name;\n    }\n\n    return output.join('.');\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { FieldDetails } from './type';\n\nexport function getFieldDetails(field: string) : FieldDetails {\n    const parts : string[] = field.split('.');\n\n    return {\n        name: parts.pop() as string,\n        path: parts.length > 0 ? parts.join('.') : undefined,\n    };\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { createMerger } from 'smob';\n\nexport const merge = createMerger({\n    clone: true,\n    inPlace: false,\n    array: true,\n    arrayDistinct: true,\n});\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { RelationsParseOutput } from '../parameter';\nimport { getFieldDetails } from './field';\nimport type { FieldDetails } from './type';\n\nexport function isFieldNonRelational(field: string | FieldDetails) {\n    const details = typeof field === 'string' ?\n        getFieldDetails(field) :\n        field;\n\n    return typeof details.path === 'undefined';\n}\n\nexport function isFieldPathAllowedByRelations(\n    field: string | Pick<FieldDetails, 'path'>,\n    includes?: RelationsParseOutput,\n) : boolean {\n    if (typeof includes === 'undefined') {\n        return true;\n    }\n\n    const details : Pick<FieldDetails, 'path'> = typeof field === 'string' ?\n        getFieldDetails(field) :\n        field;\n\n    if (\n        typeof details.path === 'undefined'\n    ) {\n        return true;\n    }\n\n    return includes.some(\n        (include) => include.key === details.path,\n    );\n}\n\nexport function buildFieldWithPath(\n    field: string | FieldDetails,\n    path?: string,\n) : string {\n    const details = typeof field === 'string' ?\n        getFieldDetails(field) :\n        field;\n\n    return details.path || path ?\n        `${details.path || path}.${details.name}` :\n        details.name;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\n\nexport function buildURLQueryString(data?: any, withQuestionMark = true) {\n    if (typeof data === 'undefined' || data === null) return '';\n\n    // If the data is already a string, return it as-is\n    if (typeof data === 'string') return data;\n\n    // Create a query array to hold the key/value pairs\n    const query : string[] = [];\n\n    // Loop through the data object\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        let value = data[keys[i]];\n\n        if (isObject(value)) {\n            const valueKeys = Object.keys(value);\n            for (let j = 0; j < valueKeys.length; j++) {\n                let v = value[valueKeys[j]];\n\n                if (Array.isArray(v)) {\n                    v = v.join(',');\n                }\n\n                query.push(`${encodeURIComponent(`${keys[i]}[${valueKeys[j]}]`)}=${encodeURIComponent(v)}`);\n            }\n\n            continue;\n        }\n\n        if (Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        // Encode each key and value, concatenate them into a string, and push them to the array\n        query.push(`${encodeURIComponent(keys[i])}=${encodeURIComponent(value)}`);\n    }\n\n    // Join each item in the array with a `&` and return the resulting string\n    return (withQuestionMark ? '?' : '') + query.join('&');\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { ObjectLiteral } from '../../type';\nimport type { FieldsBuildInput } from './type';\nimport { flattenToKeyPathArray, groupArrayByKeyPath, merge } from '../../utils';\n\nexport function buildQueryFields<T extends ObjectLiteral = ObjectLiteral>(\n    input?: FieldsBuildInput<T>,\n) : Record<string, string[]> | string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    const data = groupArrayByKeyPath(flattenToKeyPathArray(input));\n\n    const keys = Object.keys(data);\n    if (keys.length === 1) {\n        return data[keys[0]];\n    }\n\n    return data;\n}\n\nexport function mergeQueryFields(\n    target: Record<string, string[]> | string[],\n    source: Record<string, string[]> | string[],\n): Record<string, string[]> | string[] {\n    if (Array.isArray(target)) {\n        target = groupArrayByKeyPath(target);\n    }\n\n    if (Array.isArray(source)) {\n        source = groupArrayByKeyPath(source);\n    }\n\n    const data = merge(target, source);\n\n    const keys = Object.keys(data);\n    if (keys.length === 1) {\n        return data[keys[0]];\n    }\n\n    return data;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum FieldOperator {\n    INCLUDE = '+',\n    EXCLUDE = '-',\n}\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { NestedKeys, NestedResourceKeys, ObjectLiteral } from '../../../type';\nimport { flattenToKeyPathArray } from '../../../utils';\nimport type { ParseAllowedOption } from '../../type';\n\nexport function flattenParseAllowedOption<T extends ObjectLiteral>(\n    input?: ParseAllowedOption<T>,\n) : string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    return flattenToKeyPathArray(input);\n}\n\nexport function isPathCoveredByParseAllowedOption<T extends ObjectLiteral>(\n    input: ParseAllowedOption<T> |\n    NestedKeys<T>[] |\n    NestedResourceKeys<T>[],\n    path: string | string[],\n) : boolean {\n    const paths = Array.isArray(path) ? path : [path];\n\n    const items = flattenToKeyPathArray(input);\n    for (let i = 0; i < items.length; i++) {\n        if (paths.indexOf(items[i]) !== -1) {\n            return true;\n        }\n    }\n\n    return false;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { DEFAULT_ID } from '../../../constants';\n\nexport function buildFieldDomainRecords(\n    data?: Record<string, string[]> | string[],\n): Record<string, string[]> {\n    if (typeof data === 'undefined') {\n        return {};\n    }\n\n    let domainFields: Record<string, string[]> = {};\n\n    if (Array.isArray(data)) {\n        domainFields[DEFAULT_ID] = data;\n    } else {\n        domainFields = data;\n    }\n\n    return domainFields;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { FieldsInputTransformed } from '../type';\nimport { FieldOperator } from '../constants';\n\nexport function removeFieldInputOperator(field: string) {\n    const firstCharacter = field.substring(0, 1);\n\n    return firstCharacter === FieldOperator.INCLUDE ||\n        firstCharacter === FieldOperator.EXCLUDE ?\n        field.substring(1) :\n        field;\n}\n\nexport function transformFieldsInput(\n    fields: string[],\n): FieldsInputTransformed {\n    const output: FieldsInputTransformed = {\n        default: [],\n        included: [],\n        excluded: [],\n    };\n\n    for (let i = 0; i < fields.length; i++) {\n        let operator: FieldOperator | undefined;\n\n        const character = fields[i].substring(0, 1);\n\n        if (character === FieldOperator.INCLUDE) {\n            operator = FieldOperator.INCLUDE;\n        } else if (character === FieldOperator.EXCLUDE) {\n            operator = FieldOperator.EXCLUDE;\n        }\n\n        if (operator) {\n            fields[i] = fields[i].substring(1);\n\n            switch (operator) {\n                case FieldOperator.INCLUDE: {\n                    output.included.push(fields[i]);\n                    break;\n                }\n                case FieldOperator.EXCLUDE: {\n                    output.excluded.push(fields[i]);\n                    break;\n                }\n            }\n        } else {\n            output.default.push(fields[i]);\n        }\n    }\n\n    return output;\n}\n\nexport function parseFieldsInput(input: unknown): string[] {\n    let output: string[] = [];\n\n    if (typeof input === 'string') {\n        output = input.split(',');\n    } else if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (typeof input[i] === 'string') {\n                output.push(input[i]);\n            }\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isValidFieldName(input: string) : boolean {\n    return /^[a-zA-Z_][a-zA-Z0-9_]*$/gu.test(input);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\nimport type { ObjectLiteral } from '../../type';\nimport {\n    applyMapping, buildFieldWithPath, groupArrayByKeyPath, hasOwnProperty, isFieldPathAllowedByRelations, merge,\n} from '../../utils';\nimport { flattenParseAllowedOption } from '../utils';\nimport type {\n    FieldsInputTransformed, FieldsParseOptions, FieldsParseOutput,\n} from './type';\nimport {\n    isValidFieldName,\n    parseFieldsInput, removeFieldInputOperator,\n    transformFieldsInput,\n} from './utils';\nimport { DEFAULT_ID } from '../../constants';\n\n// --------------------------------------------------\n\nfunction buildReverseRecord(\n    record: Record<string, string>,\n) : Record<string, string> {\n    const keys = Object.keys(record);\n    const output : Record<string, string> = {};\n\n    for (let i = 0; i < keys.length; i++) {\n        output[record[keys[i]]] = keys[i];\n    }\n\n    return output;\n}\n\nexport function parseQueryFields<T extends ObjectLiteral = ObjectLiteral>(\n    input: unknown,\n    options?: FieldsParseOptions<T>,\n) : FieldsParseOutput {\n    options = options || {};\n\n    const defaultDomainFields = groupArrayByKeyPath(\n        flattenParseAllowedOption(options.default),\n    );\n\n    const allowedDomainFields = groupArrayByKeyPath(\n        flattenParseAllowedOption(options.allowed),\n    );\n\n    const domainFields = merge(\n        defaultDomainFields,\n        allowedDomainFields,\n    );\n\n    let keys : string[] = Object.keys(domainFields);\n\n    // If it is an empty array nothing is allowed\n    if (\n        (\n            typeof options.default !== 'undefined' ||\n            typeof options.allowed !== 'undefined'\n        ) &&\n        keys.length === 0\n    ) {\n        return [];\n    }\n\n    let data : Record<string, any> = {\n        [DEFAULT_ID]: [],\n    };\n\n    if (isObject(input)) {\n        data = input;\n    } else if (typeof input === 'string') {\n        data = { [DEFAULT_ID]: input };\n    } else if (Array.isArray(input)) {\n        data = { [DEFAULT_ID]: input };\n    }\n\n    options.mapping = options.mapping || {};\n    const reverseMapping = buildReverseRecord(options.mapping);\n\n    if (keys.length === 0) {\n        keys = Object.keys(data);\n    }\n\n    const output : FieldsParseOutput = [];\n\n    for (let i = 0; i < keys.length; i++) {\n        const path = keys[i];\n\n        if (\n            !isFieldPathAllowedByRelations({ path }, options.relations) &&\n            path !== DEFAULT_ID\n        ) {\n            continue;\n        }\n\n        let fields : string[] = [];\n\n        if (hasOwnProperty(data, path)) {\n            fields = parseFieldsInput(data[path]);\n        } else if (\n            hasOwnProperty(reverseMapping, path) &&\n            hasOwnProperty(data, reverseMapping[path])\n        ) {\n            fields = parseFieldsInput(data[reverseMapping[path]]);\n        }\n\n        let transformed : FieldsInputTransformed = {\n            default: [],\n            included: [],\n            excluded: [],\n        };\n\n        if (fields.length > 0) {\n            for (let j = 0; j < fields.length; j++) {\n                fields[j] = applyMapping(\n                    buildFieldWithPath({ name: fields[j], path }),\n                    options.mapping,\n                    true,\n                );\n            }\n\n            if (hasOwnProperty(domainFields, path)) {\n                fields = fields.filter((field) => domainFields[path].indexOf(\n                    removeFieldInputOperator(field),\n                ) !== -1);\n            } else {\n                fields = fields.filter((field) => isValidFieldName(removeFieldInputOperator(field)));\n            }\n\n            transformed = transformFieldsInput(\n                fields,\n            );\n        }\n\n        if (\n            transformed.default.length === 0 &&\n            hasOwnProperty(defaultDomainFields, path)\n        ) {\n            transformed.default = defaultDomainFields[path];\n        }\n\n        if (\n            transformed.included.length === 0 &&\n            transformed.default.length === 0 &&\n            hasOwnProperty(allowedDomainFields, path)\n        ) {\n            transformed.default = allowedDomainFields[path];\n        }\n\n        transformed.default = Array.from(new Set([\n            ...transformed.default,\n            ...transformed.included,\n        ]));\n\n        for (let j = 0; j < transformed.excluded.length; j++) {\n            const index = transformed.default.indexOf(transformed.excluded[j]);\n            if (index !== -1) {\n                transformed.default.splice(index, 1);\n            }\n        }\n\n        if (transformed.default.length > 0) {\n            for (let j = 0; j < transformed.default.length; j++) {\n                let destPath : string | undefined;\n                if (path !== DEFAULT_ID) {\n                    destPath = path;\n                } else if (options.defaultPath) {\n                    destPath = options.defaultPath;\n                }\n\n                output.push({\n                    key: transformed.default[j],\n                    ...(destPath ? { path: destPath } : {}),\n                });\n            }\n        }\n    }\n\n    return output;\n}\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum FilterComparisonOperator {\n    EQUAL = '$eq',\n    NOT_EQUAL = '$ne',\n    LIKE = '$l',\n    NOT_LIKE = '$nl',\n    LESS_THAN_EQUAL = '$lte',\n    LESS_THAN = '$lt',\n    GREATER_THAN_EQUAL = '$gte',\n    GREATER_THAN = '$gt',\n    IN = '$in',\n    NOT_IN = '$nin',\n}\n\nexport enum FilterInputOperatorValue {\n    NEGATION = '!',\n    LIKE = '~',\n    LESS_THAN_EQUAL = '<=',\n    LESS_THAN = '<',\n    MORE_THAN_EQUAL = '>=',\n    MORE_THAN = '>',\n    IN = ',',\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { flattenNestedObject, merge } from '../../utils';\nimport type { ObjectLiteral } from '../../type';\nimport type { FiltersBuildInput } from './type';\n\nexport function buildQueryFilters<T extends ObjectLiteral = ObjectLiteral>(\n    data?: FiltersBuildInput<T>,\n) : Record<string, any> {\n    if (typeof data === 'undefined') {\n        return {};\n    }\n\n    return flattenNestedObject(data, {\n        transformer: (input, output, key) => {\n            if (typeof input === 'undefined') {\n                output[key] = null;\n\n                return true;\n            }\n\n            if (Array.isArray(input)) {\n                // preserve null values\n                const data : string[] = [];\n                for (let i = 0; i < input.length; i++) {\n                    if (input[i] === null) {\n                        input[i] = 'null';\n                    }\n\n                    if (typeof input[i] === 'number') {\n                        input[i] = `${input[i]}`;\n                    }\n\n                    if (typeof input[i] === 'string') {\n                        data.push(input[i]);\n                    }\n                }\n\n                output[key] = data.join(',');\n\n                return true;\n            }\n\n            return undefined;\n        },\n    });\n}\n\nexport function mergeQueryFilters(\n    target?: Record<string, any>,\n    source?: Record<string, any>,\n) : Record<string, any> {\n    return merge(target || {}, source || {});\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { FilterValueSimple } from '../type';\n\nexport function transformFilterValue(input: FilterValueSimple) : FilterValueSimple {\n    if (typeof input === 'string') {\n        input = input.trim();\n        const lower = input.toLowerCase();\n\n        if (lower === 'true') {\n            return true;\n        }\n\n        if (lower === 'false') {\n            return false;\n        }\n\n        if (lower === 'null') {\n            return null;\n        }\n\n        if (input.length === 0) {\n            return input;\n        }\n\n        const num = Number(input);\n        if (!Number.isNaN(num)) {\n            return num;\n        }\n\n        const parts = input.split(',');\n        if (parts.length > 1) {\n            return transformFilterValue(parts);\n        }\n    }\n\n    if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            input[i] = transformFilterValue(input[i]) as string | number;\n        }\n\n        return (input as unknown[])\n            .filter((n) => n === 0 || n === null || !!n) as FilterValueSimple;\n    }\n\n    if (typeof input === 'undefined' || input === null) {\n        return null;\n    }\n\n    return input;\n}\n","/*\n * Copyright (c) 2022-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { FilterComparisonOperator, FilterInputOperatorValue } from '../constants';\nimport type { FilterValueSimple } from '../type';\n\nfunction matchOperator(key: string, value: FilterValueSimple, position: 'start' | 'end' | 'global') : FilterValueSimple | undefined {\n    if (typeof value === 'string') {\n        switch (position) {\n            case 'start': {\n                if (value.substring(0, key.length) === key) {\n                    return value.substring(key.length);\n                }\n                break;\n            }\n            case 'end': {\n                if (value.substring(0 - key.length) === key) {\n                    return value.substring(0, value.length - key.length - 1);\n                }\n                break;\n            }\n        }\n\n        return undefined;\n    }\n\n    if (Array.isArray(value)) {\n        let match = false;\n        for (let i = 0; i < value.length; i++) {\n            const output = matchOperator(key, value[i], position);\n            if (typeof output !== 'undefined') {\n                match = true;\n                value[i] = output as string | number;\n            }\n        }\n\n        if (match) {\n            return value;\n        }\n    }\n\n    return undefined;\n}\n\nexport function parseFilterValue(input: FilterValueSimple) : {\n    operator: `${FilterComparisonOperator}`,\n    value: FilterValueSimple\n} {\n    if (\n        typeof input === 'string' &&\n        input.includes(FilterInputOperatorValue.IN)\n    ) {\n        input = input.split(FilterInputOperatorValue.IN);\n    }\n\n    let negation = false;\n\n    let value = matchOperator(FilterInputOperatorValue.NEGATION, input, 'start');\n    if (typeof value !== 'undefined') {\n        negation = true;\n        input = value;\n    }\n\n    if (Array.isArray(input)) {\n        return {\n            value: input,\n            operator: negation ?\n                FilterComparisonOperator.NOT_IN :\n                FilterComparisonOperator.IN,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LIKE, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: negation ?\n                FilterComparisonOperator.NOT_LIKE :\n                FilterComparisonOperator.LIKE,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LESS_THAN_EQUAL, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.LESS_THAN_EQUAL,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.LESS_THAN, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.LESS_THAN,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.MORE_THAN_EQUAL, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.GREATER_THAN_EQUAL,\n        };\n    }\n\n    value = matchOperator(FilterInputOperatorValue.MORE_THAN, input, 'start');\n    if (typeof value !== 'undefined') {\n        return {\n            value,\n            operator: FilterComparisonOperator.GREATER_THAN,\n        };\n    }\n\n    return {\n        value: input,\n        operator: negation ?\n            FilterComparisonOperator.NOT_EQUAL :\n            FilterComparisonOperator.EQUAL,\n    };\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { NestedKeys, ObjectLiteral } from '../../type';\nimport type { FieldDetails } from '../../utils';\nimport {\n    applyMapping,\n    buildFieldWithPath,\n    flattenNestedObject,\n    getFieldDetails,\n    hasOwnProperty, isFieldNonRelational, isFieldPathAllowedByRelations,\n} from '../../utils';\nimport { isValidFieldName } from '../fields';\nimport type { ParseAllowedOption } from '../type';\nimport { flattenParseAllowedOption, isPathCoveredByParseAllowedOption } from '../utils';\nimport { FilterComparisonOperator } from './constants';\nimport type { FiltersParseOptions, FiltersParseOutput, FiltersParseOutputElement } from './type';\nimport { parseFilterValue, transformFilterValue } from './utils';\n\n// --------------------------------------------------\n\nfunction transformFiltersParseOutputElement(element: FiltersParseOutputElement) : FiltersParseOutputElement {\n    if (\n        hasOwnProperty(element, 'path') &&\n        (typeof element.path === 'undefined' || element.path === null)\n    ) {\n        delete element.path;\n    }\n\n    if (element.operator) {\n        return element;\n    }\n\n    if (typeof element.value === 'string') {\n        element = {\n            ...element,\n            ...parseFilterValue(element.value),\n        };\n    } else {\n        element.operator = FilterComparisonOperator.EQUAL;\n    }\n\n    element.value = transformFilterValue(element.value);\n\n    return element;\n}\n\nfunction buildDefaultFiltersParseOutput<T extends ObjectLiteral = ObjectLiteral>(\n    options: FiltersParseOptions<T>,\n    input: Record<string, FiltersParseOutputElement> = {},\n) : FiltersParseOutput {\n    const inputKeys = Object.keys(input || {});\n\n    if (\n        !options.defaultByElement &&\n        inputKeys.length > 0\n    ) {\n        return Object.values(input);\n    }\n\n    if (options.default) {\n        const flatten = flattenNestedObject(options.default);\n        const keys = Object.keys(flatten);\n\n        const output : FiltersParseOutput = [];\n\n        for (let i = 0; i < keys.length; i++) {\n            const fieldDetails = getFieldDetails(keys[i]);\n\n            if (\n                options.defaultByElement &&\n                inputKeys.length > 0\n            ) {\n                const fieldWithAlias = buildFieldWithPath(fieldDetails);\n                if (hasOwnProperty(input, fieldWithAlias)) {\n                    continue;\n                }\n            }\n\n            if (options.defaultByElement || inputKeys.length === 0) {\n                let path : string | undefined;\n                if (fieldDetails.path) {\n                    path = fieldDetails.path;\n                } else if (options.defaultPath) {\n                    path = options.defaultPath;\n                }\n\n                output.push(transformFiltersParseOutputElement({\n                    ...(path ? { path } : {}),\n                    key: fieldDetails.name,\n                    value: flatten[keys[i]],\n                }));\n            }\n        }\n\n        return input ? [...Object.values(input), ...output] : output;\n    }\n\n    return input ? Object.values(input) : [];\n}\n\nexport function parseQueryFilters<T extends ObjectLiteral = ObjectLiteral>(\n    data: unknown,\n    options?: FiltersParseOptions<T>,\n) : FiltersParseOutput {\n    options = options || {};\n    options.mapping = options.mapping || {};\n    options.relations = options.relations || [];\n\n    // If it is an empty array nothing is allowed\n    if (typeof options.allowed !== 'undefined') {\n        options.allowed = flattenParseAllowedOption(options.allowed) as ParseAllowedOption<T>;\n        if (options.allowed.length === 0) {\n            return buildDefaultFiltersParseOutput(options);\n        }\n    }\n\n    /* istanbul ignore next */\n    if (typeof data !== 'object' || data === null) {\n        return buildDefaultFiltersParseOutput(options);\n    }\n\n    const { length } = Object.keys(data);\n    if (length === 0) {\n        return buildDefaultFiltersParseOutput(options);\n    }\n\n    if (\n        (typeof options.allowed === 'undefined' || options.allowed.length === 0) &&\n        options.default\n    ) {\n        const flatten = flattenNestedObject(options.default);\n        options.allowed = Object.keys(flatten) as ParseAllowedOption<T>;\n    }\n\n    const items : Record<string, FiltersParseOutputElement> = {};\n\n    // transform to appreciate data format & validate input\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        /* istanbul ignore next */\n        if (!hasOwnProperty(data, keys[i])) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n\n        const value : unknown = data[keys[i]];\n\n        if (\n            typeof value !== 'string' &&\n            typeof value !== 'number' &&\n            typeof value !== 'boolean' &&\n            typeof value !== 'undefined' &&\n            value !== null &&\n            !Array.isArray(value)\n        ) {\n            continue;\n        }\n\n        keys[i] = applyMapping(keys[i], options.mapping);\n\n        const fieldDetails : FieldDetails = getFieldDetails(keys[i]);\n\n        if (\n            typeof options.allowed === 'undefined' &&\n            !isValidFieldName(fieldDetails.name)\n        ) {\n            continue;\n        }\n\n        if (\n            !isFieldPathAllowedByRelations(fieldDetails, options.relations) &&\n            !isFieldNonRelational(fieldDetails)\n        ) {\n            continue;\n        }\n\n        const fullKey : string = buildFieldWithPath(fieldDetails);\n\n        if (\n            options.allowed &&\n            !isPathCoveredByParseAllowedOption(options.allowed, [keys[i], fullKey])\n        ) {\n            continue;\n        }\n\n        const filter = transformFiltersParseOutputElement({\n            key: fieldDetails.name,\n            value: value as string | boolean | number,\n        });\n\n        if (options.validate) {\n            if (Array.isArray(filter.value)) {\n                const output : (string | number)[] = [];\n                for (let j = 0; j < filter.value.length; j++) {\n                    if (options.validate(filter.key as NestedKeys<T>, filter.value[j])) {\n                        output.push(filter.value[j]);\n                    }\n                }\n\n                filter.value = output as string[] | number[];\n                if (filter.value.length === 0) {\n                    continue;\n                }\n            } else if (!options.validate(filter.key as NestedKeys<T>, filter.value)) {\n                continue;\n            }\n        }\n\n        if (\n            typeof filter.value === 'string' &&\n            filter.value.length === 0\n        ) {\n            continue;\n        }\n\n        if (\n            Array.isArray(filter.value) &&\n            filter.value.length === 0\n        ) {\n            continue;\n        }\n\n        if (fieldDetails.path || options.defaultPath) {\n            filter.path = fieldDetails.path || options.defaultPath;\n        }\n\n        items[fullKey] = filter;\n    }\n\n    return buildDefaultFiltersParseOutput(options, items);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { merge } from '../../utils';\nimport type { PaginationBuildInput } from './type';\n\nexport function mergeQueryPagination(\n    target?: PaginationBuildInput,\n    source?: PaginationBuildInput,\n) : PaginationBuildInput {\n    return merge(target || {}, source || {});\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\nimport type { PaginationParseOptions, PaginationParseOutput } from './type';\n\n// --------------------------------------------------\n\nfunction finalizePagination(\n    data: PaginationParseOutput,\n    options: PaginationParseOptions,\n) : PaginationParseOutput {\n    if (typeof options.maxLimit !== 'undefined') {\n        if (\n            typeof data.limit === 'undefined' ||\n            data.limit > options.maxLimit\n        ) {\n            data.limit = options.maxLimit;\n        }\n    }\n\n    if (\n        typeof data.limit !== 'undefined' &&\n        typeof data.offset === 'undefined'\n    ) {\n        data.offset = 0;\n    }\n\n    return data;\n}\n\n/**\n * Transform pagination data to an appreciate data format.\n *\n * @param data\n * @param options\n */\nexport function parseQueryPagination(\n    data: unknown,\n    options?: PaginationParseOptions,\n) : PaginationParseOutput {\n    options = options || {};\n\n    const pagination : PaginationParseOutput = {};\n\n    if (!isObject(data)) {\n        return finalizePagination(pagination, options);\n    }\n\n    let { limit, offset } = data as Record<string, any>;\n\n    if (typeof limit !== 'undefined') {\n        limit = parseInt(limit, 10);\n\n        if (!Number.isNaN(limit) && limit > 0) {\n            pagination.limit = limit;\n        }\n    }\n\n    if (typeof offset !== 'undefined') {\n        offset = parseInt(offset, 10);\n\n        if (!Number.isNaN(offset) && offset >= 0) {\n            pagination.offset = offset;\n        }\n    }\n\n    return finalizePagination(pagination, options);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { ObjectLiteral } from '../../type';\nimport type { RelationsBuildInput } from './type';\nimport { flattenToKeyPathArray, merge } from '../../utils';\n\nexport function buildQueryRelations<T extends ObjectLiteral = ObjectLiteral>(\n    input?: RelationsBuildInput<T>,\n) : string[] {\n    if (typeof input === 'undefined') {\n        return [];\n    }\n\n    return flattenToKeyPathArray(input);\n}\n\nexport function mergeQueryRelations(\n    target?: string[],\n    source?: string[],\n) : string[] {\n    return merge(target || [], source || []);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function includeParents(\n    data: string[],\n) : string[] {\n    for (let i = 0; i < data.length; i++) {\n        const parts: string[] = data[i].split('.');\n\n        while (parts.length > 0) {\n            parts.pop();\n\n            if (parts.length > 0) {\n                const value = parts.join('.');\n                if (data.indexOf(value) === -1) {\n                    data.unshift(value);\n                }\n            }\n        }\n    }\n\n    return data;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isValidRelationPath(input: string) : boolean {\n    return /^[a-zA-Z0-9_-]+([.]*[a-zA-Z0-9_-])*$/gu.test(input);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { ObjectLiteral } from '../../type';\nimport { applyMapping, hasOwnProperty } from '../../utils';\nimport { isPathCoveredByParseAllowedOption } from '../utils';\n\nimport type { RelationsParseOptions, RelationsParseOutput } from './type';\nimport { includeParents, isValidRelationPath } from './utils';\n\n// --------------------------------------------------\n\nexport function parseQueryRelations<T extends ObjectLiteral = ObjectLiteral>(\n    input: unknown,\n    options: RelationsParseOptions<T> = {},\n): RelationsParseOutput {\n    options = options || {};\n\n    // If it is an empty array nothing is allowed\n    if (\n        Array.isArray(options.allowed) &&\n        options.allowed.length === 0\n    ) {\n        return [];\n    }\n\n    options.mapping = options.mapping || {};\n    options.pathMapping = options.pathMapping || {};\n    if (typeof options.includeParents === 'undefined') {\n        options.includeParents = true;\n    }\n\n    let items: string[] = [];\n\n    if (typeof input === 'string') {\n        items = input.split(',');\n    } else if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n            if (typeof input[i] === 'string') {\n                items.push(input[i]);\n            }\n        }\n    }\n\n    if (items.length === 0) {\n        return [];\n    }\n\n    const mappingKeys = Object.keys(options.mapping);\n    if (mappingKeys.length > 0) {\n        for (let i = 0; i < items.length; i++) {\n            items[i] = applyMapping(items[i], options.mapping);\n        }\n    }\n\n    if (options.allowed) {\n        items = items.filter((item) => isPathCoveredByParseAllowedOption(options.allowed as string[], item));\n    } else {\n        items = items.filter((item) => isValidRelationPath(item));\n    }\n\n    if (options.includeParents) {\n        if (Array.isArray(options.includeParents)) {\n            const parentIncludes = items.filter(\n                (item) => item.includes('.') &&\n                    (options.includeParents as string[]).filter((parent) => item.startsWith(parent)).length > 0,\n            );\n            items.unshift(...includeParents(parentIncludes));\n        } else {\n            items = includeParents(items);\n        }\n    }\n\n    items = Array.from(new Set(items));\n\n    return items\n        .map((key) => {\n            const parts = key.split('.');\n\n            let value : string;\n            if (\n                options.pathMapping &&\n                hasOwnProperty(options.pathMapping, key)\n            ) {\n                value = options.pathMapping[key];\n            } else {\n                value = parts.pop() as string;\n            }\n\n            return {\n                key,\n                value,\n            };\n        });\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type {\n    Flatten, KeyWithOptionalPrefix, NestedKeys, OnlyObject, SimpleKeys,\n} from '../../type';\nimport type { RelationsParseOutput } from '../relations';\nimport type {\n    ParseAllowedOption,\n} from '../type';\n\nexport enum SortDirection {\n    ASC = 'ASC',\n    DESC = 'DESC',\n}\n\n// -----------------------------------------------------------\n// Build\n// -----------------------------------------------------------\n\ntype SortWithOperator<T extends string> = KeyWithOptionalPrefix<T, '-'>;\n\nexport type SortBuildInput<T extends Record<string, any>> =\n    {\n        [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n            SortBuildInput<Flatten<T[K]>> :\n            `${SortDirection}`\n    }\n    |\n    (\n        SortWithOperator<SimpleKeys<T>>[] |\n        {\n            [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n                SortBuildInput<Flatten<T[K]>> :\n                `${SortDirection}`\n        }\n    )[]\n    |\n    SortWithOperator<NestedKeys<T>>[] |\n    SortWithOperator<NestedKeys<T>>;\n\n// -----------------------------------------------------------\n// Parse\n// -----------------------------------------------------------\n\nexport type SortParseDefaultOption<T extends Record<string, any>> = {\n    [K in keyof T]?: Flatten<T[K]> extends OnlyObject<T[K]> ?\n        SortParseDefaultOption<Flatten<T[K]>> :\n        `${SortDirection}`\n} | {\n    [K in NestedKeys<T>]?: `${SortDirection}`\n};\n\nexport type SortParseOptions<\n    T extends Record<string, any> = Record<string, any>,\n    > = {\n        allowed?: ParseAllowedOption<T>,\n        mapping?: Record<string, string>,\n        default?: SortParseDefaultOption<T>,\n        defaultPath?: string,\n        relations?: RelationsParseOutput,\n    };\nexport type SortParseOutputElement = {\n    key: string,\n    value: `${SortDirection}`,\n    path?: string\n};\nexport type SortParseOutput = SortParseOutputElement[];\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\nimport type { ObjectLiteral } from '../../type';\nimport type { SortBuildInput } from './type';\nimport { SortDirection } from './type';\nimport { flattenToKeyPathArray, merge } from '../../utils';\n\nexport function buildQuerySort<T extends ObjectLiteral = ObjectLiteral>(\n    data?: SortBuildInput<T>,\n) {\n    if (typeof data === 'undefined') {\n        return [];\n    }\n\n    if (typeof data === 'string') {\n        return [data];\n    }\n\n    return flattenToKeyPathArray(data, {\n        transformer: ((input, output, path) => {\n            if (\n                typeof input === 'string' &&\n                path &&\n                (\n                    input === SortDirection.ASC ||\n                    input === SortDirection.DESC\n                )\n            ) {\n                if (input === SortDirection.DESC) {\n                    output.push(`-${path}`);\n                } else {\n                    output.push(path);\n                }\n\n                return true;\n            }\n\n            return undefined;\n        }),\n    });\n}\n\nexport function mergeQuerySort(\n    target?: string[],\n    source?: string[],\n) {\n    return merge(target || [], source || []);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { SortDirection } from './type';\n\nexport function parseSortValue(value: string) : {value: string, direction: `${SortDirection}`} {\n    let direction: SortDirection = SortDirection.ASC;\n    if (value.substring(0, 1) === '-') {\n        direction = SortDirection.DESC;\n        value = value.substring(1);\n    }\n\n    return {\n        direction,\n        value,\n    };\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\nimport type { ObjectLiteral } from '../../type';\nimport {\n    applyMapping,\n    buildFieldWithPath, buildKeyPath, flattenNestedObject,\n    getFieldDetails,\n    hasOwnProperty, isFieldNonRelational,\n    isFieldPathAllowedByRelations,\n} from '../../utils';\nimport { isValidFieldName } from '../fields';\nimport type { ParseAllowedOption } from '../type';\nimport { flattenParseAllowedOption, isPathCoveredByParseAllowedOption } from '../utils';\n\nimport type {\n    SortParseOptions,\n    SortParseOutput,\n    SortParseOutputElement,\n} from './type';\nimport { parseSortValue } from './utils';\n\n// --------------------------------------------------\n\nfunction isMultiDimensionalArray(arr: unknown) : arr is unknown[][] {\n    if (!Array.isArray(arr)) {\n        return false;\n    }\n\n    return arr.length > 0 && Array.isArray(arr[0]);\n}\n\nfunction buildDefaultSortParseOutput<T extends ObjectLiteral = ObjectLiteral>(\n    options: SortParseOptions<T>,\n) : SortParseOutput {\n    if (options.default) {\n        const output : SortParseOutput = [];\n\n        const flatten = flattenNestedObject(options.default);\n        const keys = Object.keys(flatten);\n\n        for (let i = 0; i < keys.length; i++) {\n            const fieldDetails = getFieldDetails(keys[i]);\n\n            let path : string | undefined;\n            if (fieldDetails.path) {\n                path = fieldDetails.path;\n            } else if (options.defaultPath) {\n                path = options.defaultPath;\n            }\n\n            output.push({\n                key: fieldDetails.name,\n                ...(path ? { path } : {}),\n                value: flatten[keys[i]],\n            });\n        }\n\n        return output;\n    }\n\n    return [];\n}\n\n/**\n * Transform sort data to appreciate data format.\n * @param data\n * @param options\n */\nexport function parseQuerySort<T extends ObjectLiteral = ObjectLiteral>(\n    data: unknown,\n    options?: SortParseOptions<T>,\n) : SortParseOutput {\n    options = options || {};\n\n    // If it is an empty array nothing is allowed\n    if (typeof options.allowed !== 'undefined') {\n        const allowed = flattenParseAllowedOption(options.allowed) as ParseAllowedOption<T>;\n        if (allowed.length === 0) {\n            return buildDefaultSortParseOutput(options);\n        }\n    }\n\n    options.mapping = options.mapping || {};\n\n    /* istanbul ignore next */\n    if (\n        typeof data !== 'string' &&\n        !Array.isArray(data) &&\n        !isObject(data)\n    ) {\n        return buildDefaultSortParseOutput(options);\n    }\n\n    if (\n        typeof options.allowed === 'undefined' &&\n        options.default\n    ) {\n        const flatten = flattenNestedObject(options.default);\n        options.allowed = Object.keys(flatten) as ParseAllowedOption<T>;\n    }\n\n    let parts : string[] = [];\n\n    if (typeof data === 'string') {\n        parts = data.split(',');\n    }\n\n    if (Array.isArray(data)) {\n        parts = data.filter((item) => typeof item === 'string');\n    }\n\n    if (\n        typeof data === 'object' &&\n        data !== null\n    ) {\n        const keys = Object.keys(data);\n        for (let i = 0; i < keys.length; i++) {\n            /* istanbul ignore next */\n            if (\n                !hasOwnProperty(data, keys[i]) ||\n                typeof keys[i] !== 'string' ||\n                typeof data[keys[i]] !== 'string'\n            ) continue;\n\n            const fieldPrefix = (data[keys[i]] as string)\n                .toLowerCase() === 'desc' ? '-' : '';\n\n            parts.push(fieldPrefix + keys[i]);\n        }\n    }\n\n    const items : Record<string, SortParseOutputElement> = {};\n\n    let matched = false;\n\n    for (let i = 0; i < parts.length; i++) {\n        const { value, direction } = parseSortValue(parts[i]);\n        parts[i] = value;\n\n        const key: string = applyMapping(parts[i], options.mapping);\n\n        const fieldDetails = getFieldDetails(key);\n\n        if (\n            typeof options.allowed === 'undefined' &&\n            !isValidFieldName(fieldDetails.name)\n        ) {\n            continue;\n        }\n\n        if (\n            !isFieldPathAllowedByRelations(fieldDetails, options.relations) &&\n            !isFieldNonRelational(fieldDetails)\n        ) {\n            continue;\n        }\n\n        const keyWithAlias : string = buildFieldWithPath(fieldDetails);\n\n        if (\n            typeof options.allowed !== 'undefined' &&\n            !isMultiDimensionalArray(options.allowed) &&\n            !isPathCoveredByParseAllowedOption(options.allowed, [key, keyWithAlias])\n        ) {\n            continue;\n        }\n\n        matched = true;\n\n        let path : string | undefined;\n        if (fieldDetails.path) {\n            path = fieldDetails.path;\n        } else if (options.defaultPath) {\n            path = options.defaultPath;\n        }\n\n        items[keyWithAlias] = {\n            key: fieldDetails.name,\n            ...(path ? { path } : {}),\n            value: direction,\n        };\n    }\n\n    if (!matched) {\n        return buildDefaultSortParseOutput(options);\n    }\n\n    if (isMultiDimensionalArray(options.allowed)) {\n        // eslint-disable-next-line no-labels,no-restricted-syntax\n        outerLoop:\n        for (let i = 0; i < options.allowed.length; i++) {\n            const temp : SortParseOutput = [];\n\n            const keyPaths = flattenParseAllowedOption(options.allowed[i] as string[]);\n\n            for (let j = 0; j < keyPaths.length; j++) {\n                let keyWithAlias : string = keyPaths[j];\n                let key : string;\n\n                const parts = keyWithAlias.split('.');\n                if (parts.length > 1) {\n                    key = parts.pop() as string;\n                } else {\n                    key = keyWithAlias;\n\n                    keyWithAlias = buildKeyPath(key, options.defaultPath);\n                }\n\n                if (\n                    hasOwnProperty(items, key) ||\n                    hasOwnProperty(items, keyWithAlias)\n                ) {\n                    const item = hasOwnProperty(items, key) ?\n                        items[key] :\n                        items[keyWithAlias];\n\n                    temp.push(item);\n                } else {\n                    // eslint-disable-next-line no-labels\n                    continue outerLoop;\n                }\n            }\n\n            return temp;\n        }\n\n        // if we get no match, the sort data is invalid.\n        return [];\n    }\n\n    return Object.values(items);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { ObjectLiteral } from '../type';\nimport type { BuildInput } from './type';\nimport {\n    buildQueryFields,\n    buildQueryFilters,\n    buildQueryRelations,\n    buildQuerySort,\n    mergeQueryFields,\n    mergeQueryFilters,\n    mergeQueryPagination,\n    mergeQueryRelations,\n    mergeQuerySort,\n} from '../parameter';\nimport { Parameter, URLParameter } from '../constants';\nimport {\n    buildURLQueryString,\n} from '../utils';\n\nexport function buildQuery<T extends ObjectLiteral = ObjectLiteral>(\n    input?: BuildInput<T>,\n) : string {\n    if (!input) {\n        return '';\n    }\n\n    const query: { [key in URLParameter]?: unknown } = {};\n\n    if (\n        typeof input[Parameter.FIELDS] !== 'undefined' ||\n        typeof input[URLParameter.FIELDS] !== 'undefined'\n    ) {\n        query[URLParameter.FIELDS] = mergeQueryFields(\n            buildQueryFields(input[Parameter.FIELDS]),\n            buildQueryFields(input[URLParameter.FIELDS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.FILTERS] !== 'undefined' ||\n        typeof input[URLParameter.FILTERS] !== 'undefined'\n    ) {\n        query[URLParameter.FILTERS] = mergeQueryFilters(\n            buildQueryFilters(input[Parameter.FILTERS]),\n            buildQueryFilters(input[URLParameter.FILTERS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.PAGINATION] !== 'undefined' ||\n        typeof input[URLParameter.PAGINATION] !== 'undefined'\n    ) {\n        query[URLParameter.PAGINATION] = mergeQueryPagination(\n            input[Parameter.PAGINATION],\n            input[URLParameter.PAGINATION],\n        );\n    }\n\n    if (\n        typeof input[Parameter.RELATIONS] !== 'undefined' ||\n        typeof input[URLParameter.RELATIONS] !== 'undefined'\n    ) {\n        query[URLParameter.RELATIONS] = mergeQueryRelations(\n            buildQueryRelations(input[Parameter.RELATIONS]),\n            buildQueryRelations(input[URLParameter.RELATIONS]),\n        );\n    }\n\n    if (\n        typeof input[Parameter.SORT] !== 'undefined' ||\n        typeof input[URLParameter.SORT] !== 'undefined'\n    ) {\n        query[URLParameter.SORT] = mergeQuerySort(\n            buildQuerySort(input[Parameter.SORT]),\n            buildQuerySort(input[URLParameter.SORT]),\n        );\n    }\n\n    return buildURLQueryString(query);\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { RelationsParseOutput } from '../../parameter';\nimport {\n    parseQueryFields, parseQueryFilters, parseQueryPagination, parseQueryRelations, parseQuerySort,\n} from '../../parameter';\nimport {\n    Parameter, URLParameter,\n} from '../../constants';\nimport type { ObjectLiteral } from '../../type';\nimport type { ParseParameterOptions, ParseParameterOutput } from './type';\n\nexport function parseQueryParameter<\n    P extends `${Parameter}` | `${URLParameter}`,\n    T extends ObjectLiteral = ObjectLiteral,\n    >(\n    key: P,\n    data: unknown,\n    options?: ParseParameterOptions<P, T>,\n    relations?: RelationsParseOutput,\n): ParseParameterOutput<P> {\n    switch (key) {\n        case Parameter.FIELDS:\n        case URLParameter.FIELDS:\n            return (parseQueryFields(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.FIELDS>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.FILTERS:\n        case URLParameter.FILTERS:\n            return (parseQueryFilters(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.FILTERS>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.PAGINATION:\n        case URLParameter.PAGINATION:\n            return (parseQueryPagination(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.PAGINATION>,\n                },\n            ) as ParseParameterOutput<P>);\n        case Parameter.RELATIONS:\n        case URLParameter.RELATIONS:\n            return (parseQueryRelations(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.RELATIONS>,\n                },\n            ) as ParseParameterOutput<P>);\n        default:\n            return (parseQuerySort(\n                data,\n                {\n                    ...(invalidToEmptyObject(options)) as ParseParameterOptions<Parameter.SORT>,\n                    ...(relations ? { relations } : {}),\n                },\n            ) as ParseParameterOutput<P>);\n    }\n}\n\nfunction invalidToEmptyObject<V>(\n    value: V | boolean,\n): NonNullable<V> {\n    return typeof value === 'boolean' ||\n        typeof value === 'undefined' ?\n        {} as NonNullable<V> :\n        value as NonNullable<V>;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from 'smob';\n\nexport function buildQueryParameterOptions<T extends Record<string, any>>(\n    input?: T | boolean,\n) : T {\n    if (isObject(input)) {\n        return input;\n    }\n\n    return {} as T;\n}\n\ntype QueryParameterEnabledContext = {\n    data: unknown,\n    options?: Record<string, any> | boolean\n};\nexport function isQueryParameterEnabled(context: QueryParameterEnabledContext) : boolean {\n    if (typeof context.options === 'boolean') {\n        return context.options;\n    }\n\n    if (\n        typeof context.data !== 'undefined' &&\n        typeof context.options === 'undefined'\n    ) {\n        return true;\n    }\n\n    if (isObject(context.options)) {\n        if (typeof context.options.default !== 'undefined') {\n            return true;\n        }\n\n        return typeof context.data !== 'undefined';\n    }\n\n    return false;\n}\n","/*\n * Copyright (c) 2021-2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type {\n    FieldsParseOutput,\n    FiltersParseOutput,\n    PaginationParseOutput,\n    RelationsParseOutput,\n    SortParseOutput,\n} from '../parameter';\nimport { Parameter, URLParameter } from '../constants';\nimport type { ObjectLiteral } from '../type';\nimport { buildQueryParameterOptions, isQueryParameterEnabled, parseQueryParameter } from './parameter';\nimport type { ParseInput, ParseOptions, ParseOutput } from './type';\n\nexport function parseQuery<T extends ObjectLiteral = ObjectLiteral>(\n    input: ParseInput,\n    options: ParseOptions<T> = {},\n) : ParseOutput {\n    options = options || {};\n\n    const mergeWithGlobalOptions = <T extends {[key: string]: any} & {defaultPath?: string} >(data?: T) : T => {\n        if (typeof data !== 'undefined') {\n            if (options.defaultPath) {\n                data.defaultPath = options.defaultPath;\n            }\n        }\n\n        return data || {} as T;\n    };\n\n    const output : ParseOutput = {};\n    if (options.defaultPath) {\n        output.defaultPath = options.defaultPath;\n    }\n\n    let relations : RelationsParseOutput | undefined;\n\n    const keys : Parameter[] = [\n        // relations must be first parameter\n        Parameter.RELATIONS,\n\n        Parameter.FIELDS,\n        Parameter.FILTERS,\n        Parameter.PAGINATION,\n        Parameter.SORT,\n    ];\n\n    for (let i = 0; i < keys.length; i++) {\n        const key : Parameter = keys[i];\n\n        switch (key) {\n            case Parameter.RELATIONS: {\n                const value = input[Parameter.RELATIONS] || input[URLParameter.RELATIONS];\n                if (isQueryParameterEnabled({ data: value, options: options[Parameter.RELATIONS] })) {\n                    relations = parseQueryParameter(\n                        key,\n                        value,\n                        buildQueryParameterOptions(options[Parameter.RELATIONS]),\n                    );\n\n                    output[Parameter.RELATIONS] = relations;\n                }\n                break;\n            }\n            case Parameter.FIELDS: {\n                const value = input[Parameter.FIELDS] || input[URLParameter.FIELDS];\n                if (isQueryParameterEnabled({ data: value, options: options[Parameter.FIELDS] })) {\n                    output[Parameter.FIELDS] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.FIELDS])),\n                        relations,\n                    ) as FieldsParseOutput;\n                }\n                break;\n            }\n            case Parameter.FILTERS: {\n                const value = input[Parameter.FILTERS] || input[URLParameter.FILTERS];\n                if (isQueryParameterEnabled({ data: value, options: options[Parameter.FILTERS] })) {\n                    output[Parameter.FILTERS] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.FILTERS])),\n                        relations,\n                    ) as FiltersParseOutput;\n                }\n                break;\n            }\n            case Parameter.PAGINATION: {\n                const value = input[Parameter.PAGINATION] || input[URLParameter.PAGINATION];\n                if (isQueryParameterEnabled({ data: value, options: options[Parameter.PAGINATION] })) {\n                    output[Parameter.PAGINATION] = parseQueryParameter(\n                        key,\n                        value,\n                        buildQueryParameterOptions(options[Parameter.PAGINATION]),\n                        relations,\n                    ) as PaginationParseOutput;\n                }\n                break;\n            }\n            case Parameter.SORT: {\n                const value = input[Parameter.SORT] || input[URLParameter.SORT];\n                if (isQueryParameterEnabled({ data: value, options: options[Parameter.SORT] })) {\n                    output[Parameter.SORT] = parseQueryParameter(\n                        key,\n                        value,\n                        mergeWithGlobalOptions(buildQueryParameterOptions(options[Parameter.SORT])),\n                        relations,\n                    ) as SortParseOutput;\n                }\n                break;\n            }\n        }\n    }\n\n    return output;\n}\n"],"names":["Parameter","FILTERS","FIELDS","PAGINATION","RELATIONS","SORT","URLParameter","DEFAULT_ID","buildKeyPath","key","prefix","flattenToKeyPathArray","input","options","output","transformer","result","Array","isArray","i","length","j","push","keys","Object","value","data","groupArrayByKeyPath","pathItems","parts","split","name","pop","join","prototype","hasOwnProperty","call","obj","prop","flattenNestedObject","prefixParts","destinationKey","applyMapping","map","onlyKey","run","shift","found","rest","copy","last","unshift","getFieldDetails","field","path","undefined","merge","createMerger","clone","inPlace","array","arrayDistinct","isFieldNonRelational","details","isFieldPathAllowedByRelations","includes","some","include","buildFieldWithPath","buildURLQueryString","withQuestionMark","query","isObject","valueKeys","v","encodeURIComponent","buildQueryFields","mergeQueryFields","target","source","FieldOperator","INCLUDE","EXCLUDE","flattenParseAllowedOption","isPathCoveredByParseAllowedOption","paths","items","indexOf","buildFieldDomainRecords","domainFields","removeFieldInputOperator","firstCharacter","substring","transformFieldsInput","fields","default","included","excluded","operator","character","parseFieldsInput","isValidFieldName","test","buildReverseRecord","record","parseQueryFields","defaultDomainFields","allowedDomainFields","allowed","mapping","reverseMapping","relations","transformed","filter","from","Set","index","splice","destPath","defaultPath","FilterComparisonOperator","EQUAL","NOT_EQUAL","LIKE","NOT_LIKE","LESS_THAN_EQUAL","LESS_THAN","GREATER_THAN_EQUAL","GREATER_THAN","IN","NOT_IN","FilterInputOperatorValue","NEGATION","MORE_THAN_EQUAL","MORE_THAN","buildQueryFilters","mergeQueryFilters","transformFilterValue","trim","lower","toLowerCase","num","Number","isNaN","n","matchOperator","position","match","parseFilterValue","negation","transformFiltersParseOutputElement","element","buildDefaultFiltersParseOutput","inputKeys","defaultByElement","values","flatten","fieldDetails","fieldWithAlias","parseQueryFilters","fullKey","validate","mergeQueryPagination","finalizePagination","maxLimit","limit","offset","parseQueryPagination","pagination","parseInt","buildQueryRelations","mergeQueryRelations","includeParents","isValidRelationPath","parseQueryRelations","pathMapping","mappingKeys","item","parentIncludes","parent","startsWith","SortDirection","ASC","DESC","buildQuerySort","mergeQuerySort","parseSortValue","direction","isMultiDimensionalArray","arr","buildDefaultSortParseOutput","parseQuerySort","fieldPrefix","matched","keyWithAlias","outerLoop","temp","keyPaths","buildQuery","parseQueryParameter","invalidToEmptyObject","buildQueryParameterOptions","isQueryParameterEnabled","context","parseQuery","mergeWithGlobalOptions"],"mappings":"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"}