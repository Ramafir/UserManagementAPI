var oe = Object.defineProperty;
var le = (t, n, a) => n in t ? oe(t, n, { enumerable: !0, configurable: !0, writable: !0, value: a }) : t[n] = a;
var te = (t, n, a) => (le(t, typeof n != "symbol" ? n + "" : n, a), a);
import { AST_TOKEN_TYPES as $, AST_NODE_TYPES as u } from "@typescript-eslint/types";
import { ESLintUtils as ie, ASTUtils as D } from "@typescript-eslint/utils";
import pe from "natural-compare-lite";
import { minimatch as C } from "minimatch";
import ae from "is-core-module";
import ce from "json5";
import de from "path";
import fe from "fs";
let k = ie.RuleCreator(
  (t) => `https://eslint-plugin-perfectionist.azat.io/rules/${t}`
), j = (t) => t.replaceAll(/\s\s+/g, " ").trim(), P = (t) => {
  let [n, a] = t;
  return a - n;
};
var p = /* @__PURE__ */ ((t) => (t.alphabetical = "alphabetical", t["line-length"] = "line-length", t.natural = "natural", t))(p || {}), d = /* @__PURE__ */ ((t) => (t.desc = "desc", t.asc = "asc", t))(d || {});
let N = (t, n, a) => {
  var e, s;
  if ((e = n.dependencies) != null && e.includes(t.name))
    return !1;
  if ((s = t.dependencies) != null && s.includes(n.name))
    return !0;
  let r = a.order === "asc" ? 1 : -1, c, o = (i) => a["ignore-case"] ? i.toLowerCase() : i;
  return a.type === p.alphabetical ? c = (i, l) => o(i.name).localeCompare(o(l.name)) : a.type === p.natural ? c = (i, l) => pe(o(i.name), o(l.name)) : c = (i, l) => i.size - l.size, r * c(t, n) > 0;
}, A = (t, n) => [...t].sort((a, r) => Number(N(a, r, n)) || -1), ue = (t, n) => {
  let a = n.getTokenAfter(t, {
    filter: ({ value: r, type: c }) => !(c === $.Punctuator && [",", ";"].includes(r)),
    includeComments: !0
  });
  return ((a == null ? void 0 : a.type) === $.Block || (a == null ? void 0 : a.type) === $.Line) && t.loc.end.line === a.loc.end.line ? a : null;
}, re = (t, n) => Array.isArray(t) && t.some((a) => C(n.trim(), a)) || typeof t == "string" && C(n.trim(), t) || t === !0, z = (t, n) => {
  let [a, r] = n.getTokensBefore(t, {
    filter: ({ value: c, type: o }) => !(o === $.Punctuator && [",", ";"].includes(c)),
    includeComments: !0,
    count: 2
  });
  return ((r == null ? void 0 : r.type) === $.Block || (r == null ? void 0 : r.type) === $.Line) && t.loc.start.line - r.loc.end.line <= 1 && (a == null ? void 0 : a.loc.end.line) !== r.loc.start.line ? r : null;
}, L = (t, n, a) => {
  var s;
  let r = t.range.at(0), c = t.range.at(1), o = n.text.slice(r, c);
  if (D.isParenthesized(t, n)) {
    let i = n.getTokenBefore(
      t,
      D.isOpeningParenToken
    ), l = n.getTokenAfter(
      t,
      D.isClosingParenToken
    );
    r = i.range.at(0), c = l.range.at(1);
  }
  let e = z(t, n);
  if (o.endsWith(";") || o.endsWith(",")) {
    let i = n.getTokensAfter(t, {
      includeComments: !0,
      count: 2
    });
    t.loc.start.line === ((s = i.at(1)) == null ? void 0 : s.loc.start.line) && (c -= 1);
  }
  return e && !re(
    (a == null ? void 0 : a.partitionComment) ?? !1,
    e.value
  ) && (r = e.range.at(0)), [r, c];
}, R = (t, n, a, r, c) => {
  let o = [];
  for (let e = 0, s = n.length; e < s; e++) {
    let { node: i } = n.at(e);
    o.push(
      t.replaceTextRange(
        L(i, r, c),
        r.text.slice(
          ...L(a.at(e).node, r, c)
        )
      )
    );
    let l = ue(a.at(e).node, r);
    if (l) {
      let h = [
        r.getTokenBefore(l).range.at(1),
        l.range.at(1)
      ];
      o.push(t.replaceTextRange(h, ""));
      let b = r.getTokenAfter(i);
      o.push(
        t.insertTextAfter(
          (b == null ? void 0 : b.loc.end.line) === i.loc.end.line ? b : i,
          r.text.slice(...h)
        )
      );
    }
  }
  return o;
}, v = (t = {}, n) => Object.assign(n, t), T = (t, n) => {
  if (t.length > 1)
    for (let a = 1; a < t.length; a++) {
      let r = t.at(a - 1), c = t.at(a);
      r && c && n(r, c, a - 1);
    }
};
const J = "sort-array-includes", me = k({
  name: J,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted arrays before include method",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "spread-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedArrayIncludesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => ({
    MemberExpression: (n) => {
      if ((n.object.type === u.ArrayExpression || n.object.type === u.NewExpression) && n.property.type === u.Identifier && n.property.name === "includes") {
        let a = n.object.type === u.ArrayExpression ? n.object.elements : n.object.arguments;
        if (a.length > 1) {
          let r = v(t.options.at(0), {
            type: p.alphabetical,
            order: d.asc,
            "ignore-case": !1,
            "spread-last": !1
          }), c = t.getSourceCode(), o = a.reduce(
            (e, s) => (s !== null && e.at(0).push({
              name: s.type === u.Literal ? s.raw : c.text.slice(...s.range),
              size: P(s.range),
              type: s.type,
              node: s
            }), e),
            [[], []]
          ).flat();
          T(o, (e, s) => {
            let i;
            r["spread-last"] && e.node.type === u.Literal && s.node.type === u.SpreadElement ? i = !1 : r["spread-last"] && e.node.type === u.SpreadElement && s.node.type === u.Literal ? i = !0 : i = N(e, s, r), i && t.report({
              messageId: "unexpectedArrayIncludesOrder",
              data: {
                left: j(e.name),
                right: j(s.name)
              },
              node: s.node,
              fix: (l) => {
                let m = A(o, r);
                if (r["spread-last"])
                  for (let h = 0, b = m.length; h < b; h++)
                    m.at(h).node.type === u.SpreadElement && m.push(m.splice(h, 1).at(0));
                return R(l, o, m, c);
              }
            });
          });
        }
      }
    }
  })
}), G = "sort-named-exports", ge = k({
  name: G,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named exports",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => ({
    ExportNamedDeclaration: (n) => {
      if (n.specifiers.length > 1) {
        let a = v(t.options.at(0), {
          type: p.alphabetical,
          "ignore-case": !1,
          order: d.asc
        }), r = t.getSourceCode(), c = n.specifiers.map((o) => ({
          size: P(o.range),
          name: o.local.name,
          node: o
        }));
        T(c, (o, e) => {
          N(o, e, a) && t.report({
            messageId: "unexpectedNamedExportsOrder",
            data: {
              left: o.name,
              right: e.name
            },
            node: e.node,
            fix: (s) => R(s, c, A(c, a), r)
          });
        });
      }
    }
  })
}), W = "sort-named-imports", ye = k({
  name: W,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named imports",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => ({
    ImportDeclaration: (n) => {
      let a = n.specifiers.filter(
        ({ type: r }) => r === u.ImportSpecifier
      );
      if (a.length > 1) {
        let r = v(t.options.at(0), {
          type: p.alphabetical,
          "ignore-case": !1,
          order: d.asc
        }), c = t.getSourceCode(), o = a.map((e) => ({
          size: P(e.range),
          name: e.local.name,
          node: e
        }));
        T(o, (e, s) => {
          N(e, s, r) && t.report({
            messageId: "unexpectedNamedImportsOrder",
            data: {
              left: e.name,
              right: s.name
            },
            node: s.node,
            fix: (i) => R(i, o, A(o, r), c)
          });
        });
      }
    }
  })
}), X = "sort-object-types", he = k({
  name: X,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted object types",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => ({
    TSTypeLiteral: (n) => {
      if (n.members.length > 1) {
        let a = v(t.options.at(0), {
          type: p.alphabetical,
          "ignore-case": !1,
          order: d.asc
        }), r = t.getSourceCode(), c = n.members.map((o) => {
          var h, b;
          let e, s = r.text.slice(o.range.at(0), o.range.at(1)), i = (E) => E.replace(/(,|;)$/, "");
          if (o.type === u.TSPropertySignature)
            o.key.type === u.Identifier ? { name: e } = o.key : o.key.type === u.Literal ? e = `${o.key.value}` : e = r.text.slice(
              o.range.at(0),
              (h = o.typeAnnotation) == null ? void 0 : h.range.at(0)
            );
          else if (o.type === u.TSIndexSignature) {
            let E = ((b = o.typeAnnotation) == null ? void 0 : b.range.at(0)) ?? o.range.at(1);
            e = i(r.text.slice(o.range.at(0), E));
          } else
            e = i(
              r.text.slice(o.range.at(0), o.range.at(1))
            );
          let m = s.endsWith(";") || s.endsWith(",") ? 1 : 0;
          return {
            size: P(o.range) - m,
            node: o,
            name: e
          };
        });
        T(c, (o, e) => {
          N(o, e, a) && t.report({
            messageId: "unexpectedObjectTypesOrder",
            data: {
              left: j(o.name),
              right: j(e.name)
            },
            node: e.node,
            fix: (s) => R(s, c, A(c, a), r)
          });
        });
      }
    }
  })
}), K = "sort-map-elements", be = k({
  name: K,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Map elements",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedMapElementsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => ({
    NewExpression: (n) => {
      if (n.callee.type === u.Identifier && n.callee.name === "Map" && n.arguments.length && n.arguments[0].type === u.ArrayExpression) {
        let [{ elements: a }] = n.arguments;
        if (a.length > 1) {
          let r = v(t.options.at(0), {
            type: p.alphabetical,
            "ignore-case": !1,
            order: d.asc
          }), c = t.getSourceCode(), o = a.reduce(
            (e, s) => (s === null || s.type === u.SpreadElement ? e.push([]) : e.at(-1).push(s), e),
            [[]]
          );
          for (let e of o) {
            let s = e.map((i) => {
              let l;
              if (i.type === u.ArrayExpression) {
                let [m] = i.elements;
                m ? m.type === u.Literal ? l = m.raw : l = c.text.slice(...m.range) : l = `${m}`;
              } else
                l = c.text.slice(...i.range);
              return {
                size: P(i.range),
                node: i,
                name: l
              };
            });
            T(s, (i, l) => {
              N(i, l, r) && t.report({
                messageId: "unexpectedMapElementsOrder",
                data: {
                  left: j(i.name),
                  right: j(l.name)
                },
                node: l.node,
                fix: (m) => R(m, s, A(s, r), c)
              });
            });
          }
        }
      }
    }
  })
}), V = "sort-union-types", xe = k({
  name: V,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted union types",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedUnionTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => ({
    TSUnionType: (n) => {
      let a = t.getSourceCode(), r = v(t.options.at(0), {
        type: p.alphabetical,
        "ignore-case": !1,
        order: d.asc
      }), c = n.types.map((o) => ({
        name: a.text.slice(...o.range),
        size: P(o.range),
        node: o
      }));
      T(c, (o, e) => {
        N(o, e, r) && t.report({
          messageId: "unexpectedUnionTypesOrder",
          data: {
            left: j(o.name),
            right: j(e.name)
          },
          node: e.node,
          fix: (s) => R(s, c, A(c, r), a)
        });
      });
    }
  })
}), Y = "sort-interfaces", Ee = k({
  name: Y,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted interface properties",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-pattern": {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedInterfacePropertiesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => ({
    TSInterfaceDeclaration: (n) => {
      if (n.body.body.length > 1) {
        let a = v(t.options.at(0), {
          type: p.alphabetical,
          "ignore-case": !1,
          order: d.asc,
          "ignore-pattern": []
        });
        if (!a["ignore-pattern"].some(
          (r) => C(n.id.name, r)
        )) {
          let r = t.getSourceCode(), c = n.body.body.reduce(
            (o, e) => {
              var i, l, m;
              if (e.type === u.TSCallSignatureDeclaration)
                return o.push([]), o;
              let s;
              if (e.type === u.TSPropertySignature)
                if (e.key.type === u.Identifier)
                  ({ name: s } = e.key);
                else if (e.key.type === u.Literal)
                  s = `${e.key.value}`;
                else {
                  let h = ((i = e.typeAnnotation) == null ? void 0 : i.range.at(0)) ?? e.range.at(1) - (e.optional ? 1 : 0);
                  s = r.text.slice(e.range.at(0), h);
                }
              else if (e.type === u.TSIndexSignature) {
                let h = ((l = e.typeAnnotation) == null ? void 0 : l.range.at(0)) ?? e.range.at(1);
                s = r.text.slice(e.range.at(0), h);
              } else {
                let h = ((m = e.returnType) == null ? void 0 : m.range.at(0)) ?? e.range.at(1);
                s = r.text.slice(e.range.at(0), h);
              }
              return o.at(-1).push({
                size: P(e.range),
                node: e,
                name: s
              }), o;
            },
            [[]]
          );
          for (let o of c)
            T(o, (e, s) => {
              N(e, s, a) && t.report({
                messageId: "unexpectedInterfacePropertiesOrder",
                data: {
                  left: j(e.name),
                  right: j(s.name)
                },
                node: s.node,
                fix: (i) => R(i, o, A(o, a), r)
              });
            });
        }
      }
    }
  })
});
let se = (t, n) => t.reduce((a, r) => {
  let c = n(r);
  return c in a || (a[c] = []), a[c].push(r), a;
}, {});
const q = "sort-jsx-props", we = k({
  name: q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted JSX props",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "always-on-top": {
            type: "array",
            default: []
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          shorthand: {
            enum: [
              "first",
              "last",
              "ignore"
              /* ignore */
            ]
          },
          callback: {
            enum: [
              "first",
              "last",
              "ignore"
              /* ignore */
            ]
          },
          multiline: {
            enum: [
              "first",
              "last",
              "ignore"
              /* ignore */
            ]
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedJSXPropsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => ({
    JSXElement: (n) => {
      if (n.openingElement.attributes.length > 1) {
        let a = v(t.options.at(0), {
          type: p.alphabetical,
          shorthand: "ignore",
          multiline: "ignore",
          callback: "ignore",
          "always-on-top": [],
          "ignore-case": !1,
          order: d.asc
        }), r = t.getSourceCode(), c = n.openingElement.attributes.reduce(
          (o, e) => {
            if (e.type === u.JSXSpreadAttribute)
              return o.push([]), o;
            let s = "ignore";
            e.name.type === u.JSXIdentifier && a["always-on-top"].includes(e.name.name) ? s = "exception" : (a.shorthand !== "ignore" && e.value === null && (s = a.shorthand), a.callback !== "ignore" && e.name.type === u.JSXIdentifier && e.name.name.indexOf("on") === 0 && e.value !== null ? s = a.callback : a.multiline !== "ignore" && e.loc.start.line !== e.loc.end.line && (s = a.multiline));
            let i = {
              name: e.name.type === u.JSXNamespacedName ? `${e.name.namespace.name}:${e.name.name.name}` : e.name.name,
              size: P(e.range),
              node: e,
              position: s
            };
            return o.at(-1).push(i), o;
          },
          [[]]
        );
        for (let o of c)
          T(o, (e, s) => {
            let i;
            if (e.position === "exception" && s.position === "exception")
              i = a["always-on-top"].indexOf(e.name) > a["always-on-top"].indexOf(s.name);
            else if (e.position === s.position)
              i = N(e, s, a);
            else {
              let l = {
                exception: 2,
                first: 1,
                ignore: 0,
                last: -1
              };
              i = l[e.position] < l[s.position];
            }
            i && t.report({
              messageId: "unexpectedJSXPropsOrder",
              data: {
                left: e.name,
                right: s.name
              },
              node: s.node,
              fix: (l) => {
                let m = se(o, ({ position: E }) => E), h = (E) => E in m ? m[E] : [], b = [
                  h(
                    "exception"
                    /* exception */
                  ).sort(
                    (E, I) => a["always-on-top"].indexOf(E.name) - a["always-on-top"].indexOf(I.name)
                  ),
                  A(h(
                    "first"
                    /* first */
                  ), a),
                  A(h(
                    "ignore"
                    /* ignore */
                  ), a),
                  A(h(
                    "last"
                    /* last */
                  ), a)
                ].flat();
                return R(l, o, b, r);
              }
            });
          });
      }
    }
  })
});
class ne {
  static get() {
    return this._instance ? this._instance : (this._instance = ce.parse(
      fe.readFileSync(de.resolve(process.cwd(), "tsconfig.json"), "utf8")
    ), this._instance);
  }
}
te(ne, "_instance");
const H = "sort-imports", Ie = k({
  name: H,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted imports",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object",
            properties: {
              type: {
                type: "object"
              },
              value: {
                type: "object"
              }
            },
            additionalProperties: !1
          },
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          },
          "internal-pattern": {
            type: "array",
            default: ["~/**"]
          },
          "newlines-between": {
            enum: [
              "ignore",
              "always",
              "never"
              /* never */
            ],
            default: "always"
            /* always */
          },
          "read-tsconfig": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"',
      missedSpacingBetweenImports: 'Missed spacing between "{{left}}" and "{{right}}" imports',
      extraSpacingBetweenImports: 'Extra spacing between "{{left}}" and "{{right}}" imports'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => {
    var i;
    let n = v(t.options.at(0), {
      "newlines-between": "always",
      "custom-groups": { type: {}, value: {} },
      "internal-pattern": ["~/**"],
      type: p.alphabetical,
      "read-tsconfig": !1,
      order: d.asc,
      "ignore-case": !1,
      groups: []
    }), a = [];
    if (n["read-tsconfig"]) {
      let l = ne.get();
      if ((i = l.compilerOptions) != null && i.paths)
        for (let m of Object.keys(l.compilerOptions.paths))
          a.push(m);
    }
    let r = t.getSourceCode(), c = [], o = (l) => l.type === u.ImportDeclaration && l.specifiers.length === 0, e = (l) => {
      let m, h = (y) => [".less", ".scss", ".sass", ".styl", ".pcss", ".css", ".sss"].some(
        (S) => y.endsWith(S)
      ), b = (y) => [
        "./index.d.js",
        "./index.d.ts",
        "./index.js",
        "./index.ts",
        "./index",
        "./",
        "."
      ].includes(y), E = (y) => y.indexOf("..") === 0, I = (y) => y.indexOf("./") === 0, f = (y) => {
        !m && n.groups.flat().includes(y) && (m = y);
      }, g = (y) => n["internal-pattern"].length && n["internal-pattern"].some(
        (S) => C(y.source.value, S)
      ) || a.some((S) => C(y.source.value, S)), x = (y, S) => {
        for (let [w, O] of Object.entries(
          n["custom-groups"][y] ?? {}
        ))
          Array.isArray(O) && O.some((M) => C(S, M)) && f(w), typeof O == "string" && C(S, O) && f(w);
      };
      return l.importKind === "type" && (l.type === u.ImportDeclaration && (x("type", l.source.value), ae(l.source.value) && f("builtin-type"), g(l) && f("internal-type"), b(l.source.value) && f("index-type"), E(l.source.value) && f("parent-type"), I(l.source.value) && f("sibling-type")), f("external-type"), f("type")), !m && l.type === u.ImportDeclaration && (x("value", l.source.value), ae(l.source.value) && f("builtin"), g(l) && f("internal"), h(l.source.value) && f("style"), o(l) && f("side-effect"), b(l.source.value) && f("index"), E(l.source.value) && f("parent"), I(l.source.value) && f("sibling"), f("external")), m ?? "unknown";
    }, s = (l) => {
      let m;
      l.type === u.ImportDeclaration ? m = l.source.value : l.moduleReference.type === u.TSExternalModuleReference && l.moduleReference.expression.type === u.Literal ? m = `${l.moduleReference.expression.value}` : m = r.text.slice(...l.moduleReference.range), c.push({
        size: P(l.range),
        group: e(l),
        name: m,
        node: l
      });
    };
    return {
      TSImportEqualsDeclaration: s,
      ImportDeclaration: s,
      "Program:exit": () => {
        var I;
        let l = (f) => {
          for (let g = 0, x = n.groups.length; g < x; g++) {
            let y = n.groups[g];
            if (f.group === y || Array.isArray(y) && y.includes(f.group))
              return g;
          }
          return n.groups.length;
        }, m = (f, g) => !!r.getTokensBetween(
          f.node,
          z(g.node, r) || g.node,
          {
            includeComments: !0
          }
        ).length, h = (f, g) => r.lines.slice(
          f.node.loc.end.line,
          g.node.loc.start.line - 1
        ).filter((y) => !y.trim().length).length, b = (f, g) => {
          let x = [], y = {};
          for (let w of g) {
            let O = l(w);
            O in y ? y[O] = A(
              [...y[O], w],
              n
            ) : y[O] = [w];
          }
          let S = Object.keys(y).sort().reduce(
            (w, O) => [...w, ...y[O]],
            []
          );
          for (let w = 0, O = S.length; w < O; w++) {
            let M = S.at(w);
            if (x.push(
              f.replaceTextRange(
                L(g.at(w).node, r),
                r.text.slice(...L(M.node, r))
              )
            ), n["newlines-between"] !== "ignore") {
              let B = S.at(w + 1);
              if (B) {
                let _ = h(
                  g.at(w),
                  g.at(w + 1)
                );
                (n["newlines-between"] === "always" && l(M) === l(B) && _ !== 0 || n["newlines-between"] === "never" && _ > 0) && x.push(
                  f.removeRange([
                    L(g.at(w).node, r).at(1),
                    L(g.at(w + 1).node, r).at(0) - 1
                  ])
                ), n["newlines-between"] === "always" && l(M) !== l(B) && _ > 1 && x.push(
                  f.replaceTextRange(
                    [
                      L(g.at(w).node, r).at(1),
                      L(g.at(w + 1).node, r).at(
                        0
                      ) - 1
                    ],
                    `
`
                  )
                ), n["newlines-between"] === "always" && l(M) !== l(B) && _ === 0 && x.push(
                  f.insertTextAfterRange(
                    L(g.at(w).node, r),
                    `
`
                  )
                );
              }
            }
          }
          return x;
        }, E = [[]];
        for (let f of c) {
          let g = (I = E.at(-1)) == null ? void 0 : I.at(-1);
          g && m(g, f) ? E.push([f]) : E.at(-1).push(f);
        }
        for (let f of E)
          T(f, (g, x) => {
            let y = l(g), S = l(x), w = h(g, x);
            !(o(g.node) && o(x.node)) && !m(g, x) && (y > S || y === S && N(g, x, n)) && t.report({
              messageId: "unexpectedImportsOrder",
              data: {
                left: g.name,
                right: x.name
              },
              node: x.node,
              fix: (O) => b(O, f)
            }), n["newlines-between"] === "never" && w > 0 && t.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: g.name,
                right: x.name
              },
              node: x.node,
              fix: (O) => b(O, f)
            }), n["newlines-between"] === "always" && (y < S && w === 0 ? t.report({
              messageId: "missedSpacingBetweenImports",
              data: {
                left: g.name,
                right: x.name
              },
              node: x.node,
              fix: (O) => b(O, f)
            }) : (w > 1 || y === S && w > 0) && t.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: g.name,
                right: x.name
              },
              node: x.node,
              fix: (O) => b(O, f)
            }));
          });
      }
    };
  }
}), Q = "sort-classes", Oe = k({
  name: Q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted classes",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          groups: {
            type: "array",
            default: ["property", "constructor", "method", "unknown"]
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedClassesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => ({
    ClassBody: (n) => {
      if (n.body.length > 1) {
        let a = v(t.options.at(0), {
          type: p.alphabetical,
          order: d.asc,
          "ignore-case": !1,
          groups: ["property", "constructor", "method", "unknown"]
        }), r = t.getSourceCode(), c = n.body.map((e) => {
          var m;
          let s, i;
          e.type === u.StaticBlock ? i = "static" : e.type === u.TSIndexSignature ? i = r.text.slice(
            e.range.at(0),
            ((m = e.typeAnnotation) == null ? void 0 : m.range.at(0)) ?? e.range.at(1)
          ) : e.key.type === u.Identifier ? { name: i } = e.key : i = r.text.slice(...e.key.range);
          let l = (h) => {
            !s && a.groups.flat().includes(h) && (s = h);
          };
          return e.type === u.MethodDefinition ? (e.kind === "constructor" && l("constructor"), e.static && l("static-method"), e.accessibility === "private" && l("private-method"), l("method")) : e.type === u.PropertyDefinition && (e.static && l("static-property"), e.accessibility === "private" && l("private-property"), l("property")), {
            size: P(e.range),
            group: s ?? "unknown",
            node: e,
            name: i
          };
        }), o = (e) => {
          for (let s = 0, i = a.groups.length; s < i; s++) {
            let l = a.groups[s];
            if (e.group === l || Array.isArray(l) && l.includes(e.group))
              return s;
          }
          return a.groups.length;
        };
        T(c, (e, s) => {
          let i = o(e), l = o(s);
          (i > l || i === l && N(e, s, a)) && t.report({
            messageId: "unexpectedClassesOrder",
            data: {
              left: j(e.name),
              right: j(s.name)
            },
            node: s.node,
            fix: (m) => {
              let h = [], b = c.reduce(
                (I, f) => {
                  let g = o(f);
                  return g in I ? I[g] = A(
                    [...I[g], f],
                    a
                  ) : I[g] = [f], I;
                },
                {}
              ), E = Object.keys(b).sort().reduce(
                (I, f) => [
                  ...I,
                  ...b[f]
                ],
                []
              );
              for (let I = 0, f = E.length; I < f; I++)
                h.push(
                  m.replaceTextRange(
                    L(c.at(I).node, r),
                    r.text.slice(
                      ...L(E.at(I).node, r)
                    )
                  )
                );
              return h;
            }
          });
        });
      }
    }
  })
}), Z = "sort-objects", Se = k({
  name: Z,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted objects",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "partition-by-comment": {
            type: ["boolean", "string", "array"],
            default: !1
          },
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "always-on-top": {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => {
    let n = (a) => {
      if (a.properties.length > 1) {
        let r = v(t.options.at(0), {
          "partition-by-comment": !1,
          type: p.alphabetical,
          "ignore-case": !1,
          order: d.asc,
          "always-on-top": []
        }), c = t.getSourceCode(), o = (e) => e.reduce(
          (s, i) => {
            if (i.type === u.SpreadElement || i.type === u.RestElement)
              return s.push([]), s;
            let l = z(i, c);
            r["partition-by-comment"] && l && re(
              r["partition-by-comment"],
              l.value
            ) && s.push([]);
            let m, h = "ignore", b = [];
            if (i.key.type === u.Identifier ? { name: m } = i.key : i.key.type === u.Literal ? m = `${i.key.value}` : m = c.text.slice(...i.key.range), i.key.type === u.Identifier && r["always-on-top"].includes(i.key.name) && (h = "exception"), i.value.type === u.AssignmentPattern) {
              let I = (f, g) => {
                f.right.type === u.Identifier && b.push(f.right.name), !g && f.left.type === u.Identifier && b.push(f.left.name);
                let x = (y) => {
                  y.right.type === u.Identifier && b.push(y.right.name), y.left.type === u.BinaryExpression && I(y.left, !1);
                };
                f.right.type === u.BinaryExpression && x(f.right);
              };
              I(i.value, !0);
            }
            let E = {
              size: P(i.range),
              dependencies: b,
              node: i,
              position: h,
              name: m
            };
            return s.at(-1).push(E), s;
          },
          [[]]
        );
        for (let e of o(a.properties))
          T(e, (s, i) => {
            let l;
            if (s.position === "exception" && i.position === "exception")
              l = r["always-on-top"].indexOf(s.name) > r["always-on-top"].indexOf(i.name);
            else if (s.position === i.position)
              l = N(s, i, r);
            else {
              let m = {
                exception: 1,
                ignore: 0
              };
              l = m[s.position] < m[i.position];
            }
            if (l) {
              let m = (h) => {
                let b = se(e, ({ position: f }) => f), E = (f) => f in b ? b[f] : [], I = [
                  E(
                    "exception"
                    /* exception */
                  ).sort(
                    (f, g) => r["always-on-top"].indexOf(f.name) - r["always-on-top"].indexOf(g.name)
                  ),
                  A(E(
                    "ignore"
                    /* ignore */
                  ), r)
                ].flat();
                return R(h, e, I, c, {
                  partitionComment: r["partition-by-comment"]
                });
              };
              t.report({
                messageId: "unexpectedObjectsOrder",
                data: {
                  left: j(s.name),
                  right: j(i.name)
                },
                node: i.node,
                fix: m
              });
            }
          });
      }
    };
    return {
      ObjectExpression: n,
      ObjectPattern: n
    };
  }
}), F = "sort-exports", je = k({
  name: F,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted exports",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => {
    let n = v(t.options.at(0), {
      type: p.alphabetical,
      order: d.asc,
      "ignore-case": !1
    }), a = [[]], r = (c) => {
      c.type === u.ExportAllDeclaration && c.exported === null ? a.push([]) : a.at(-1).push({
        size: P(c.range),
        name: c.source.value,
        node: c
      });
    };
    return {
      ExportAllDeclaration: r,
      ExportNamedDeclaration: (c) => {
        c.source !== null && r(c);
      },
      "Program:exit": () => {
        let c = t.getSourceCode();
        for (let o of a)
          T(o, (e, s) => {
            N(e, s, n) && t.report({
              messageId: "unexpectedExportsOrder",
              data: {
                left: e.name,
                right: s.name
              },
              node: s.node,
              fix: (i) => R(i, o, A(o, n), c)
            });
          });
      }
    };
  }
}), ee = "sort-enums", Ae = k({
  name: ee,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted TypeScript enums",
      recommended: !1
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedEnumsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (t) => ({
    TSEnumDeclaration: (n) => {
      if (n.members.length > 1 && n.members.some(({ initializer: a }) => a)) {
        let a = v(t.options.at(0), {
          type: p.alphabetical,
          order: d.asc,
          "ignore-case": !1
        }), r = t.getSourceCode(), c = n.members.map((o) => ({
          name: o.id.type === u.Literal ? `${o.id.value}` : `${r.text.slice(...o.id.range)}`,
          size: P(o.range),
          node: o
        }));
        T(c, (o, e) => {
          N(o, e, a) && t.report({
            messageId: "unexpectedEnumsOrder",
            data: {
              left: j(o.name),
              right: j(e.name)
            },
            node: e.node,
            fix: (s) => R(s, c, A(c, a), r)
          });
        });
      }
    }
  })
}), Ne = "eslint-plugin-perfectionist";
let U = (t) => {
  let n = {
    [H]: [
      "error",
      {
        groups: [
          "type",
          ["builtin", "external"],
          "internal-type",
          "internal",
          ["parent-type", "sibling-type", "index-type"],
          ["parent", "sibling", "index"],
          "object",
          "unknown"
        ],
        "custom-groups": {
          value: {},
          type: {}
        },
        "newlines-between": "always",
        "internal-pattern": ["~/**"],
        "read-tsconfig": !1
      }
    ],
    [Q]: [
      "error",
      {
        groups: [
          "static-property",
          "private-property",
          "property",
          "constructor",
          "static-method",
          "private-method",
          "method",
          "unknown"
        ]
      }
    ],
    [q]: [
      "error",
      {
        "always-on-top": [],
        shorthand: "ignore",
        multiline: "first",
        callback: "ignore"
      }
    ],
    [Z]: [
      "error",
      {
        "partition-by-comment": !1,
        "always-on-top": []
      }
    ],
    [J]: [
      "error",
      {
        "spread-last": !0
      }
    ],
    [G]: ["error"],
    [W]: ["error"],
    [K]: ["error"],
    [X]: ["error"],
    [Y]: ["error"],
    [V]: ["error"],
    [F]: ["error"],
    [ee]: ["error"]
  };
  return {
    rules: Object.fromEntries(
      Object.entries(n).map(([a, [r, c = {}]]) => [
        `perfectionist/${a}`,
        [r, Object.assign(c, t)]
      ])
    ),
    plugins: ["perfectionist"]
  };
};
const Be = {
  rules: {
    [J]: me,
    [Q]: Oe,
    [ee]: Ae,
    [F]: je,
    [H]: Ie,
    [Y]: Ee,
    [q]: we,
    [K]: be,
    [G]: ge,
    [W]: ye,
    [X]: he,
    [Z]: Se,
    [V]: xe
  },
  configs: {
    "recommended-alphabetical": U({
      type: p.alphabetical,
      order: d.asc,
      "ignore-case": !1
    }),
    "recommended-natural": U({
      type: p.natural,
      order: d.asc,
      "ignore-case": !1
    }),
    "recommended-line-length": U({
      type: p["line-length"],
      order: d.desc
    })
  },
  name: Ne
};
export {
  Be as default
};
